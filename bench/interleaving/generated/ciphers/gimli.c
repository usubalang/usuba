/* This code was generated by Usuba.
   See https://github.com/DadaIsCrazy/usuba.
   From the file "samples/usuba/gimli.ua" (included below). */

#include <stdint.h>

/* Do NOT change the order of those define/include */

#ifndef BITS_PER_REG
#define BITS_PER_REG 32
#endif
/* including the architecture specific .h */
#include "STD.h"

/* auxiliary functions */
void SPbox_Rx__V32 (/*inputs*/ DATATYPE col__0__,DATATYPE col__1__,DATATYPE col__2__, /*outputs*/ DATATYPE* colR__0__,DATATYPE* colR__1__,DATATYPE* colR__2__) {

  // Variables declaration
  DATATYPE _tmp10_;
  DATATYPE _tmp1_;
  DATATYPE _tmp2_;
  DATATYPE _tmp3_;
  DATATYPE _tmp4_;
  DATATYPE _tmp5_;
  DATATYPE _tmp6_;
  DATATYPE _tmp7_;
  DATATYPE _tmp8_;
  DATATYPE _tmp9_;
  DATATYPE x__;
  DATATYPE x_R__;
  DATATYPE y__;

  // Instructions (body)
  x__ = L_ROTATE(col__0__,24,32);
  y__ = L_ROTATE(col__1__,9,32);
  _tmp1_ = L_SHIFT(col__2__,1,32);
  x_R__ = x__;
  _tmp3_ = AND(y__,col__2__);
  _tmp5_ = XOR(y__,x__);
  _tmp8_ = XOR(col__2__,y__);
  _tmp2_ = XOR(x__,_tmp1_);
  _tmp6_ = OR(x_R__,col__2__);
  _tmp9_ = AND(x_R__,y__);
  _tmp4_ = L_SHIFT(_tmp3_,2,32);
  _tmp7_ = L_SHIFT(_tmp6_,1,32);
  _tmp10_ = L_SHIFT(_tmp9_,3,32);
  *colR__2__ = XOR(_tmp2_,_tmp4_);
  *colR__1__ = XOR(_tmp5_,_tmp7_);
  *colR__0__ = XOR(_tmp8_,_tmp10_);

}

void SPbox_Rxy__V32 (/*inputs*/ DATATYPE col__0__,DATATYPE col__1__,DATATYPE col__2__, /*outputs*/ DATATYPE* colR__0__,DATATYPE* colR__1__,DATATYPE* colR__2__) {

  // Variables declaration
  DATATYPE _tmp11_;
  DATATYPE _tmp12_;
  DATATYPE _tmp13_;
  DATATYPE _tmp14_;
  DATATYPE _tmp15_;
  DATATYPE _tmp16_;
  DATATYPE _tmp17_;
  DATATYPE _tmp18_;
  DATATYPE _tmp19_;
  DATATYPE _tmp20_;
  DATATYPE x__;
  DATATYPE x_R__;
  DATATYPE y__;
  DATATYPE y_R__;

  // Instructions (body)
  x__ = L_ROTATE(col__0__,24,32);
  y__ = L_ROTATE(col__1__,9,32);
  _tmp11_ = L_SHIFT(col__2__,1,32);
  x_R__ = x__;
  y_R__ = y__;
  _tmp15_ = XOR(y__,x__);
  _tmp18_ = XOR(col__2__,y__);
  _tmp12_ = XOR(x__,_tmp11_);
  _tmp16_ = OR(x_R__,col__2__);
  _tmp13_ = AND(y_R__,col__2__);
  _tmp19_ = AND(x_R__,y_R__);
  _tmp17_ = L_SHIFT(_tmp16_,1,32);
  _tmp14_ = L_SHIFT(_tmp13_,2,32);
  _tmp20_ = L_SHIFT(_tmp19_,3,32);
  *colR__1__ = XOR(_tmp15_,_tmp17_);
  *colR__2__ = XOR(_tmp12_,_tmp14_);
  *colR__0__ = XOR(_tmp18_,_tmp20_);

}

/* main function */
void gimli__ (/*inputs*/ DATATYPE state__[3][4], /*outputs*/ DATATYPE stateR__[3][4]) {

  // Variables declaration
  DATATYPE _tmp28_[3][4];
  DATATYPE _tmp29_[3][4];
  DATATYPE _tmp30_[3][4];
  DATATYPE _tmp31_[3][4];
  DATATYPE _tmp32_[3][4];
  DATATYPE _tmp33_[3][4];
  DATATYPE rc__[6];
  DATATYPE round__[3][4];

  // Instructions (body)
  round__[0][0] = state__[0][0];
  round__[0][1] = state__[0][1];
  round__[0][2] = state__[0][2];
  round__[0][3] = state__[0][3];
  round__[1][0] = state__[1][0];
  round__[1][1] = state__[1][1];
  round__[1][2] = state__[1][2];
  round__[1][3] = state__[1][3];
  round__[2][0] = state__[2][0];
  round__[2][1] = state__[2][1];
  round__[2][2] = state__[2][2];
  round__[2][3] = state__[2][3];
  rc__[0] = LIFT_32(0x9e377918);
  rc__[1] = LIFT_32(0x9e377914);
  rc__[2] = LIFT_32(0x9e377910);
  rc__[3] = LIFT_32(0x9e37790c);
  rc__[4] = LIFT_32(0x9e377908);
  rc__[5] = LIFT_32(0x9e377904);
  for (int r__ = 0; r__ <= 5; r__++) {
    for (int i__1 = 0; i__1 <= 3; i__1++) {
      SPbox_Rx__V32(round__[0][i__1],round__[1][i__1],round__[2][i__1],&_tmp28_[0][i__1],&_tmp28_[1][i__1],&_tmp28_[2][i__1]);
    }
    _tmp29_[0][0] = _tmp28_[0][1];
    _tmp29_[0][1] = _tmp28_[0][0];
    _tmp29_[0][2] = _tmp28_[0][3];
    _tmp29_[0][3] = _tmp28_[0][2];
    _tmp29_[1][0] = _tmp28_[1][0];
    _tmp29_[1][1] = _tmp28_[1][1];
    _tmp29_[1][2] = _tmp28_[1][2];
    _tmp29_[1][3] = _tmp28_[1][3];
    _tmp29_[2][0] = _tmp28_[2][0];
    _tmp29_[2][1] = _tmp28_[2][1];
    _tmp30_[0][0] = XOR(_tmp29_[0][0],rc__[r__]);
    _tmp30_[0][1] = _tmp29_[0][1];
    _tmp30_[0][2] = _tmp29_[0][2];
    _tmp30_[0][3] = _tmp29_[0][3];
    _tmp30_[1][0] = _tmp29_[1][0];
    _tmp30_[1][1] = _tmp29_[1][1];
    _tmp30_[1][2] = _tmp29_[1][2];
    _tmp30_[1][3] = _tmp29_[1][3];
    _tmp30_[2][0] = _tmp29_[2][0];
    _tmp30_[2][1] = _tmp29_[2][1];
    _tmp29_[2][2] = _tmp28_[2][2];
    _tmp29_[2][3] = _tmp28_[2][3];
    _tmp30_[2][2] = _tmp29_[2][2];
    _tmp30_[2][3] = _tmp29_[2][3];
    for (int i__4 = 0; i__4 <= 3; i__4++) {
      SPbox_Rxy__V32(_tmp30_[0][i__4],_tmp30_[1][i__4],_tmp30_[2][i__4],&_tmp31_[0][i__4],&_tmp31_[1][i__4],&_tmp31_[2][i__4]);
    }
    for (int i__2 = 0; i__2 <= 3; i__2++) {
      SPbox_Rx__V32(_tmp31_[0][i__2],_tmp31_[1][i__2],_tmp31_[2][i__2],&_tmp32_[0][i__2],&_tmp32_[1][i__2],&_tmp32_[2][i__2]);
    }
    _tmp33_[0][0] = _tmp32_[0][2];
    _tmp33_[0][1] = _tmp32_[0][3];
    _tmp33_[0][2] = _tmp32_[0][0];
    _tmp33_[0][3] = _tmp32_[0][1];
    _tmp33_[1][0] = _tmp32_[1][0];
    _tmp33_[1][1] = _tmp32_[1][1];
    _tmp33_[1][2] = _tmp32_[1][2];
    _tmp33_[1][3] = _tmp32_[1][3];
    _tmp33_[2][0] = _tmp32_[2][0];
    _tmp33_[2][1] = _tmp32_[2][1];
    _tmp33_[2][2] = _tmp32_[2][2];
    _tmp33_[2][3] = _tmp32_[2][3];
    for (int i__3 = 0; i__3 <= 3; i__3++) {
      SPbox_Rx__V32(_tmp33_[0][i__3],_tmp33_[1][i__3],_tmp33_[2][i__3],&round__[0][i__3],&round__[1][i__3],&round__[2][i__3]);
    }
  }
  stateR__[0][0] = round__[0][0];
  stateR__[0][1] = round__[0][1];
  stateR__[0][2] = round__[0][2];
  stateR__[0][3] = round__[0][3];
  stateR__[1][0] = round__[1][0];
  stateR__[1][1] = round__[1][1];
  stateR__[1][2] = round__[1][2];
  stateR__[1][3] = round__[1][3];
  stateR__[2][0] = round__[2][0];
  stateR__[2][1] = round__[2][1];
  stateR__[2][2] = round__[2][2];
  stateR__[2][3] = round__[2][3];

}

/* Additional functions */
uint32_t bench_speed() {
  /* Inputs */
  DATATYPE state__[3][4];

  /* Preventing inputs from being optimized out */
  asm volatile("" : "+m" (state__));

  /* Outputs */
  DATATYPE stateR__[3][4];
  /* Primitive call */
  gimli__(state__,stateR__);

  /* Preventing outputs from being optimized out */
  asm volatile("" : "+m" (stateR__));

  /* Returning the number of encrypted bytes */
  return 48;
}

/* **************************************************************** */
/*                            Usuba source                          */
/*                                                                  */
/*

 node SPbox_Rx(col :  u32[3])
  returns colR :  u32[3]
vars
  x :  u32,
  y :  u32,
  z :  u32,
  x_R :  u32
let
  (x) = (col[0] <<< 24);
  (y) = (col[1] <<< 9);
  (z) = col[2];
  (x_R) = refresh(x);
  (colR[2]) = ((x ^ (z << 1)) ^ ((y & z) << 2));
  (colR[1]) = ((y ^ x) ^ ((x_R | z) << 1));
  (colR[0]) = ((z ^ y) ^ ((x_R & y) << 3))
tel

 node SPbox_Rxy(col :  u32[3])
  returns colR :  u32[3]
vars
  x :  u32,
  y :  u32,
  z :  u32,
  x_R :  u32,
  y_R :  u32
let
  (x) = (col[0] <<< 24);
  (y) = (col[1] <<< 9);
  (z) = col[2];
  (x_R) = refresh(x);
  (y_R) = refresh(y);
  (colR[2]) = ((x ^ (z << 1)) ^ ((y_R & z) << 2));
  (colR[1]) = ((y ^ x) ^ ((x_R | z) << 1));
  (colR[0]) = ((z ^ y) ^ ((x_R & y_R) << 3))
tel

 node NonlinearLayer_Rx(state :  u32x4[3])
  returns stateR :  u32x4[3]
vars

let
  forall i in [0,3] {
    (stateR[0 .. 2][i]) = SPbox_Rx(state[0 .. 2][i])
  }
tel

 node NonlinearLayer_Rxy(state :  u32x4[3])
  returns stateR :  u32x4[3]
vars

let
  forall i in [0,3] {
    (stateR[0 .. 2][i]) = SPbox_Rxy(state[0 .. 2][i])
  }
tel

 node SmallSwap(state :  u32x4[3])
  returns stateR :  u32x4[3]
vars

let
  (stateR) = (state[0][1,0,3,2],state[1,2][0 .. 3])
tel

 node BigSwap(state :  u32x4[3])
  returns stateR :  u32x4[3]
vars

let
  (stateR) = (state[0][2,3,0,1],state[1,2][0 .. 3])
tel

 node AddRC(state :  u32x4[3],rc :  u32)
  returns stateR :  u32x4[3]
vars

let
  (stateR) = ((state[0][0] ^ rc),state[0][1 .. 3],state[1,2])
tel

 node gimli(state :  u32x4[3])
  returns stateR :  u32x4[3]
vars
  rc :  u32[6],
  round :  u32x4[7][3]
let
  (rc) = (0x9e377918:u32,0x9e377914:u32,0x9e377910:u32,0x9e37790c:u32,0x9e377908:u32,0x9e377904:u32);
  (round[0]) = state;
  forall r in [0,5] {
    (round[(r + 1)]) = NonlinearLayer_Rx(BigSwap(NonlinearLayer_Rx(NonlinearLayer_Rxy(AddRC(SmallSwap(NonlinearLayer_Rx(round[r])),rc[r])))))
  };
  (stateR) = round[6]
tel

*/
 