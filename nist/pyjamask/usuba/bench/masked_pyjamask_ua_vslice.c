/* This code was generated by Usuba.
   See https://github.com/DadaIsCrazy/usuba.
   From the file "nist/pyjamask/usuba/ua/pyjamask_vslice.ua" (included below). */

#include <stdint.h>

/* Do NOT change the order of those define/include */

#ifndef BITS_PER_REG
#define BITS_PER_REG 32
#endif
/* including the architecture specific .h */
#include "MASKED.h"

/* auxiliary functions */
void SubBytes__V32 (/*inputs*/ DATATYPE s0[MASKING_ORDER],DATATYPE s1[MASKING_ORDER],DATATYPE s2[MASKING_ORDER],DATATYPE s3[MASKING_ORDER], /*outputs*/ DATATYPE ret[4][MASKING_ORDER]) {

  // Variables declaration
  DATATYPE _shadow_s01_[MASKING_ORDER];
  DATATYPE _shadow_s03_[MASKING_ORDER];
  DATATYPE _shadow_s14_[MASKING_ORDER];
  DATATYPE _shadow_s17_[MASKING_ORDER];
  DATATYPE _shadow_s25_[MASKING_ORDER];
  DATATYPE _shadow_s26_[MASKING_ORDER];
  DATATYPE _shadow_s32_[MASKING_ORDER];
  DATATYPE _shadow_s38_[MASKING_ORDER];
  DATATYPE _tmp1_[MASKING_ORDER];
  DATATYPE _tmp2_[MASKING_ORDER];
  DATATYPE _tmp3_[MASKING_ORDER];
  DATATYPE _tmp4_[MASKING_ORDER];

  // Instructions (body)
  XOR(_shadow_s01_,s0,s3);
  AND(_tmp1_,_shadow_s01_,s1);
  XOR(_shadow_s32_,s3,_tmp1_);
  AND(_tmp2_,s1,s2);
  XOR(_shadow_s03_,_shadow_s01_,_tmp2_);
  AND(_tmp3_,s2,_shadow_s32_);
  XOR(_shadow_s14_,s1,_tmp3_);
  AND(_tmp4_,_shadow_s03_,_shadow_s32_);
  XOR(_shadow_s25_,s2,_tmp4_);
  XOR(_shadow_s26_,_shadow_s25_,_shadow_s14_);
  XOR(_shadow_s17_,_shadow_s14_,_shadow_s03_);
  NOT(_shadow_s38_,_shadow_s32_);
  ASGN(ret[0],_shadow_s03_);
  ASGN(ret[1],_shadow_s17_);
  ASGN(ret[2],_shadow_s38_);
  ASGN(ret[3],_shadow_s26_);

}

void AddRoundKey__V32 (/*inputs*/ DATATYPE i__[4][MASKING_ORDER],DATATYPE k__[4][MASKING_ORDER], /*outputs*/ DATATYPE o__[4][MASKING_ORDER]) {

  // Variables declaration
  ;

  // Instructions (body)
  XOR(o__[0],i__[0],k__[0]);
  XOR(o__[1],i__[1],k__[1]);
  XOR(o__[2],i__[2],k__[2]);
  XOR(o__[3],i__[3],k__[3]);

}

void mat_mult__V32 (/*inputs*/ DATATYPE col__[MASKING_ORDER],DATATYPE vec__[MASKING_ORDER], /*outputs*/ DATATYPE res__[MASKING_ORDER]) {

  // Variables declaration
  DATATYPE _tmp5_[MASKING_ORDER];
  DATATYPE _tmp6_[MASKING_ORDER];
  DATATYPE mask__[MASKING_ORDER];
  DATATYPE mat_col__[MASKING_ORDER];
  DATATYPE res_tmp__[MASKING_ORDER];

  // Instructions (body)
  ASGN(mat_col__,col__);
  ASGN_CST(res_tmp__, LIFT_32(0));
  for (int i__ = 0; i__ <= 31; i__++) {
    L_SHIFT(_tmp5_,vec__,i__,32);
    RA_SHIFT(mask__,_tmp5_,31,32);
    AND(_tmp6_,mask__,mat_col__);
    XOR(res_tmp__,res_tmp__,_tmp6_);
    R_ROTATE(mat_col__,mat_col__,1,32);
  }
  ASGN(res__,res_tmp__);

}

void MixRows__V32 (/*inputs*/ DATATYPE input__[4][MASKING_ORDER], /*outputs*/ DATATYPE output__[4][MASKING_ORDER]) {

  // Variables declaration
  DATATYPE M__[4][MASKING_ORDER];

  // Instructions (body)
  ASGN_CST(M__[0], LIFT_32(2743472261));
  ASGN_CST(M__[1], LIFT_32(1665232929));
  ASGN_CST(M__[2], LIFT_32(1764553344));
  ASGN_CST(M__[3], LIFT_32(1218791443));
  for (int i__ = 0; i__ <= 3; i__++) {
    mat_mult__V32(M__[i__],input__[i__],output__[i__]);
  }

}

/* main function */
void pyjamask__ (/*inputs*/ DATATYPE plaintext__[4][MASKING_ORDER],DATATYPE key__[15][4][MASKING_ORDER], /*outputs*/ DATATYPE ciphertext__[4][MASKING_ORDER]) {

  // Variables declaration
  DATATYPE _tmp11_[4][MASKING_ORDER];
  DATATYPE _tmp12_[4][MASKING_ORDER];
  DATATYPE round__[4][MASKING_ORDER];

  // Instructions (body)
  ASGN(round__[0],plaintext__[0]);
  ASGN(round__[1],plaintext__[1]);
  ASGN(round__[2],plaintext__[2]);
  ASGN(round__[3],plaintext__[3]);
  for (int i__ = 0; i__ <= 13; i__++) {
    AddRoundKey__V32(round__,key__[i__],_tmp11_);
    SubBytes__V32(_tmp11_[0],_tmp11_[1],_tmp11_[2],_tmp11_[3],_tmp12_);
    MixRows__V32(_tmp12_,round__);
  }
  AddRoundKey__V32(round__,key__[14],ciphertext__);

}

/* Additional functions */
uint32_t bench_speed() {
  /* inputs */
  DATATYPE plaintext__[4][MASKING_ORDER] = { 0 };
  DATATYPE key__[15][4][MASKING_ORDER] = { 0 };
  /* outputs */
  DATATYPE ciphertext__[4][MASKING_ORDER] = { 0 };
  /* fun call */
  pyjamask__(plaintext__, key__,ciphertext__);

  /* Returning the number of encrypted bytes */
  return 16;
}

/* **************************************************************** */
/*                            Usuba source                          */
/*                                                                  */
/*

 table SubBytes(i :  v4 :: base)
  returns o :  v4 :: base
{
  2, 13, 3, 9, 7, 11, 10, 6, 14, 0, 15, 4, 8, 5, 1, 12
}


 node AddRoundKey(i :  u32x4 :: base,k :  u32x4 :: base)
  returns o :  u32x4 :: base
vars

let
  (o) = (i ^ k)
tel

 node mat_mult(col :  u32 :: base,vec :  u32 :: base)
  returns res :  u32 :: base
vars
  mat_col :  u32[33] :: base,
  res_tmp :  u32[33] :: base,
  mask :  u32[32] :: base
let
  (mat_col[0]) = col;
  (res_tmp[0]) = 0;
  forall i in [0,31] {
    (mask[i]) = ((vec << i) >>! 31);
    (res_tmp[(i + 1)]) = (res_tmp[i] ^ (mask[i] & mat_col[i]));
    (mat_col[(i + 1)]) = (mat_col[i] >>> 1)
  };
  (res) = res_tmp[32]
tel

 node MixRows(input :  u32x4 :: base)
  returns output :  u32x4 :: base
vars
  M :  u32[4] :: base
let
  (M) = (2743472261,1665232929,1764553344,1218791443);
  forall i in [0,3] {
    (output[i]) = mat_mult(M[i],input[i])
  }
tel

 node pyjamask(plaintext :  u32x4 :: base,key :  u32x4[15] :: base)
  returns ciphertext :  u32x4 :: base
vars
  round :  u32x4[15] :: base
let
  (round[0]) = plaintext;
  forall i in [0,13] {
    (round[(i + 1)]) = MixRows(SubBytes(AddRoundKey(round[i],key[i])))
  };
  (ciphertext) = AddRoundKey(round[14],key[14])
tel

*/
 