/* This code was generated by Usuba.
   See https://github.com/DadaIsCrazy/usuba.
   From the file "nist/drygascon/usuba/ua/drygascon.ua" (included below). */

#include <stdint.h>

/* Do NOT change the order of those define/include */

#ifndef BITS_PER_REG
#define BITS_PER_REG 64
#endif
/* including the architecture specific .h */
#include "MASKED_UA.h"

/* auxiliary functions */
void Sbox__V64 (/*inputs*/ DATATYPE x[5][MASKING_ORDER], /*outputs*/ DATATYPE xr[5][MASKING_ORDER]) {

  // Variables declaration
  DATATYPE _shadow_t04_[MASKING_ORDER];
  DATATYPE _shadow_t15_[MASKING_ORDER];
  DATATYPE _shadow_t26_[MASKING_ORDER];
  DATATYPE _shadow_t37_[MASKING_ORDER];
  DATATYPE _shadow_t48_[MASKING_ORDER];
  DATATYPE _shadow_x015_;
  DATATYPE _shadow_x01_[MASKING_ORDER];
  DATATYPE _shadow_x09_;
  DATATYPE _shadow_x110_;
  DATATYPE _shadow_x114_;
  DATATYPE _shadow_x211_[MASKING_ORDER];
  DATATYPE _shadow_x217_[MASKING_ORDER];
  DATATYPE _shadow_x23_[MASKING_ORDER];
  DATATYPE _shadow_x312_;
  DATATYPE _shadow_x316_;
  DATATYPE _shadow_x413_;
  DATATYPE _shadow_x42_[MASKING_ORDER];
  DATATYPE t0[MASKING_ORDER];
  DATATYPE t1[MASKING_ORDER];
  DATATYPE t2[MASKING_ORDER];
  DATATYPE t3[MASKING_ORDER];
  DATATYPE t4[MASKING_ORDER];

  // Instructions (body)
  for (int _mask_idx = 0; _mask_idx <= (MASKING_ORDER - 1); _mask_idx++) {
    _shadow_x01_[_mask_idx] = XOR(x[0][_mask_idx],x[4][_mask_idx]);
    _shadow_x42_[_mask_idx] = XOR(x[4][_mask_idx],x[3][_mask_idx]);
    _shadow_x23_[_mask_idx] = XOR(x[2][_mask_idx],x[1][_mask_idx]);
  }
  t0[0] = NOT(_shadow_x01_[0]);
  for (int _mask_idx = 1; _mask_idx <= (MASKING_ORDER - 1); _mask_idx++) {
    t0[_mask_idx] = _shadow_x01_[_mask_idx];
    t1[_mask_idx] = x[1][_mask_idx];
    t2[_mask_idx] = _shadow_x23_[_mask_idx];
    t3[_mask_idx] = x[3][_mask_idx];
    t4[_mask_idx] = _shadow_x42_[_mask_idx];
  }
  t1[0] = NOT(x[1][0]);
  t2[0] = NOT(_shadow_x23_[0]);
  t3[0] = NOT(x[3][0]);
  t4[0] = NOT(_shadow_x42_[0]);
  MASKED_AND(_shadow_t04_,t0,x[1]);
  MASKED_AND(_shadow_t15_,t1,_shadow_x23_);
  MASKED_AND(_shadow_t26_,t2,x[3]);
  MASKED_AND(_shadow_t37_,t3,_shadow_x42_);
  MASKED_AND(_shadow_t48_,t4,_shadow_x01_);
  for (int _mask_idx = 0; _mask_idx <= (MASKING_ORDER - 1); _mask_idx++) {
    _shadow_x09_ = XOR(_shadow_x01_[_mask_idx],_shadow_t15_[_mask_idx]);
    _shadow_x110_ = XOR(x[1][_mask_idx],_shadow_t26_[_mask_idx]);
    _shadow_x211_[_mask_idx] = XOR(_shadow_x23_[_mask_idx],_shadow_t37_[_mask_idx]);
    _shadow_x312_ = XOR(x[3][_mask_idx],_shadow_t48_[_mask_idx]);
    _shadow_x413_ = XOR(_shadow_x42_[_mask_idx],_shadow_t04_[_mask_idx]);
    _shadow_x114_ = XOR(_shadow_x110_,_shadow_x09_);
    _shadow_x015_ = XOR(_shadow_x09_,_shadow_x413_);
    _shadow_x316_ = XOR(_shadow_x312_,_shadow_x211_[_mask_idx]);
    xr[0][_mask_idx] = _shadow_x015_;
    xr[1][_mask_idx] = _shadow_x114_;
    xr[3][_mask_idx] = _shadow_x316_;
    xr[4][_mask_idx] = _shadow_x413_;
  }
  _shadow_x217_[0] = NOT(_shadow_x211_[0]);
  for (int _mask_idx = 1; _mask_idx <= (MASKING_ORDER - 1); _mask_idx++) {
    _shadow_x217_[_mask_idx] = _shadow_x211_[_mask_idx];
  }
  for (int _mask_idx = 0; _mask_idx <= (MASKING_ORDER - 1); _mask_idx++) {
    xr[2][_mask_idx] = _shadow_x217_[_mask_idx];
  }

}

void AddConstant__V64 (/*inputs*/ DATATYPE state__[5][MASKING_ORDER],DATATYPE c__[MASKING_ORDER], /*outputs*/ DATATYPE stateR__[5][MASKING_ORDER]) {

  // Variables declaration
  DATATYPE _tmp1_;

  // Instructions (body)
  for (int _mask_idx = 0; _mask_idx <= (MASKING_ORDER - 1); _mask_idx++) {
    _tmp1_ = XOR(state__[2][_mask_idx],c__[_mask_idx]);
    stateR__[0][_mask_idx] = state__[0][_mask_idx];
    stateR__[1][_mask_idx] = state__[1][_mask_idx];
    stateR__[2][_mask_idx] = _tmp1_;
    stateR__[3][_mask_idx] = state__[3][_mask_idx];
    stateR__[4][_mask_idx] = state__[4][_mask_idx];
  }

}

void Rotr32__V_Natnat_64 (/*inputs*/ DATATYPE x__[MASKING_ORDER],unsigned int n__, /*outputs*/ DATATYPE y__[MASKING_ORDER]) {

  // Variables declaration
  DATATYPE _tmp2_;
  DATATYPE _tmp3_;
  DATATYPE _tmp4_[MASKING_ORDER];
  DATATYPE _tmp75_[MASKING_ORDER];

  // Instructions (body)
  for (int _mask_idx = 0; _mask_idx <= (MASKING_ORDER - 1); _mask_idx++) {
    _tmp2_ = R_SHIFT(x__[_mask_idx],n__,64);
    _tmp3_ = L_SHIFT(x__[_mask_idx],(32 - n__),64);
    _tmp4_[_mask_idx] = XOR(_tmp2_,_tmp3_);
  }
  _tmp75_[0] = LIFT_64(4294967295);
  for (int _mask_idx = 1; _mask_idx <= (MASKING_ORDER - 1); _mask_idx++) {
    _tmp75_[_mask_idx] = LIFT_64(0);
  }
  for (int _mask_idx = 0; _mask_idx <= (MASKING_ORDER - 1); _mask_idx++) {
    y__[_mask_idx] = AND(_tmp4_[_mask_idx],_tmp75_[0]);
  }

}

void BitRotR_odd__V_Natnat_64 (/*inputs*/ DATATYPE x__[MASKING_ORDER],unsigned int shift__, /*outputs*/ DATATYPE y__[MASKING_ORDER]) {

  // Variables declaration
  DATATYPE _shadow_i1__18_[MASKING_ORDER];
  unsigned int _tmp12_;
  unsigned int _tmp14_;
  DATATYPE _tmp15_[MASKING_ORDER];
  DATATYPE _tmp17_;
  unsigned int _tmp8_;
  DATATYPE i0__[MASKING_ORDER];
  DATATYPE i1__[MASKING_ORDER];
  DATATYPE t__[MASKING_ORDER];
  DATATYPE _tmp77_;
  DATATYPE _tmp76_[MASKING_ORDER];

  // Instructions (body)
  _tmp76_[0] = LIFT_64(4294967295);
  for (int _mask_idx = 1; _mask_idx <= (MASKING_ORDER - 1); _mask_idx++) {
    _tmp76_[_mask_idx] = LIFT_64(0);
    _tmp77_ = LIFT_64(0);
  }
  for (int _mask_idx = 0; _mask_idx <= (MASKING_ORDER - 1); _mask_idx++) {
    i0__[_mask_idx] = AND(x__[_mask_idx],_tmp76_[0]);
    i1__[_mask_idx] = R_SHIFT(x__[_mask_idx],32,64);
  }
  _tmp8_ = ((shift__) / (2));
  Rotr32__V_Natnat_64(i1__,_tmp8_,t__);
  _tmp12_ = ((_tmp8_) + (1));
  _tmp14_ = ((_tmp12_) % (32));
  Rotr32__V_Natnat_64(i0__,_tmp14_,_shadow_i1__18_);
  for (int _mask_idx = 0; _mask_idx <= (MASKING_ORDER - 1); _mask_idx++) {
    _tmp15_[_mask_idx] = L_SHIFT(_shadow_i1__18_[_mask_idx],32,64);
  }
  _tmp77_ = LIFT_64(4294967295);
  for (int _mask_idx = 0; _mask_idx <= (MASKING_ORDER - 1); _mask_idx++) {
    _tmp17_ = AND(t__[_mask_idx],_tmp77_);
    y__[_mask_idx] = XOR(_tmp15_[_mask_idx],_tmp17_);
  }

}

void BitRotR_eve__V_Natnat_64 (/*inputs*/ DATATYPE x__[MASKING_ORDER],unsigned int shift__, /*outputs*/ DATATYPE y__[MASKING_ORDER]) {

  // Variables declaration
  DATATYPE _shadow_i0__20_[MASKING_ORDER];
  DATATYPE _shadow_i1__21_[MASKING_ORDER];
  unsigned int _tmp20_;
  DATATYPE _tmp23_[MASKING_ORDER];
  DATATYPE _tmp25_;
  DATATYPE i0__[MASKING_ORDER];
  DATATYPE i1__[MASKING_ORDER];
  DATATYPE _tmp79_;
  DATATYPE _tmp78_[MASKING_ORDER];

  // Instructions (body)
  _tmp78_[0] = LIFT_64(4294967295);
  for (int _mask_idx = 1; _mask_idx <= (MASKING_ORDER - 1); _mask_idx++) {
    _tmp78_[_mask_idx] = LIFT_64(0);
    _tmp79_ = LIFT_64(0);
  }
  for (int _mask_idx = 0; _mask_idx <= (MASKING_ORDER - 1); _mask_idx++) {
    i0__[_mask_idx] = AND(x__[_mask_idx],_tmp78_[0]);
    i1__[_mask_idx] = R_SHIFT(x__[_mask_idx],32,64);
  }
  _tmp20_ = ((shift__) / (2));
  Rotr32__V_Natnat_64(i0__,_tmp20_,_shadow_i0__20_);
  Rotr32__V_Natnat_64(i1__,_tmp20_,_shadow_i1__21_);
  for (int _mask_idx = 0; _mask_idx <= (MASKING_ORDER - 1); _mask_idx++) {
    _tmp23_[_mask_idx] = L_SHIFT(_shadow_i1__21_[_mask_idx],32,64);
  }
  _tmp79_ = LIFT_64(4294967295);
  for (int _mask_idx = 0; _mask_idx <= (MASKING_ORDER - 1); _mask_idx++) {
    _tmp25_ = AND(_shadow_i0__20_[_mask_idx],_tmp79_);
    y__[_mask_idx] = XOR(_tmp23_[_mask_idx],_tmp25_);
  }

}

void LinearLayer__V64 (/*inputs*/ DATATYPE state__[5][MASKING_ORDER], /*outputs*/ DATATYPE stateR__[5][MASKING_ORDER]) {

  // Variables declaration
  DATATYPE _tmp27_[MASKING_ORDER];
  DATATYPE _tmp29_[MASKING_ORDER];
  DATATYPE _tmp30_;
  DATATYPE _tmp32_[MASKING_ORDER];
  DATATYPE _tmp34_[MASKING_ORDER];
  DATATYPE _tmp35_;
  DATATYPE _tmp37_[MASKING_ORDER];
  DATATYPE _tmp39_[MASKING_ORDER];
  DATATYPE _tmp40_;
  DATATYPE _tmp42_[MASKING_ORDER];
  DATATYPE _tmp44_[MASKING_ORDER];
  DATATYPE _tmp45_;
  DATATYPE _tmp47_[MASKING_ORDER];
  DATATYPE _tmp49_[MASKING_ORDER];
  DATATYPE _tmp50_;
  unsigned int _tmp89_;
  unsigned int _tmp88_;
  unsigned int _tmp87_;
  unsigned int _tmp86_;
  unsigned int _tmp85_;
  unsigned int _tmp84_;
  unsigned int _tmp83_;
  unsigned int _tmp82_;
  unsigned int _tmp81_;
  unsigned int _tmp80_;

  // Instructions (body)
  _tmp80_ = 19;
  BitRotR_odd__V_Natnat_64(state__[0],_tmp80_,_tmp27_);
  _tmp81_ = 28;
  BitRotR_eve__V_Natnat_64(state__[0],_tmp81_,_tmp29_);
  for (int _mask_idx = 0; _mask_idx <= (MASKING_ORDER - 1); _mask_idx++) {
    _tmp30_ = XOR(_tmp27_[_mask_idx],_tmp29_[_mask_idx]);
    stateR__[0][_mask_idx] = XOR(state__[0][_mask_idx],_tmp30_);
  }
  _tmp82_ = 61;
  BitRotR_odd__V_Natnat_64(state__[1],_tmp82_,_tmp32_);
  _tmp83_ = 38;
  BitRotR_eve__V_Natnat_64(state__[1],_tmp83_,_tmp34_);
  for (int _mask_idx = 0; _mask_idx <= (MASKING_ORDER - 1); _mask_idx++) {
    _tmp35_ = XOR(_tmp32_[_mask_idx],_tmp34_[_mask_idx]);
    stateR__[1][_mask_idx] = XOR(state__[1][_mask_idx],_tmp35_);
  }
  _tmp84_ = 1;
  BitRotR_odd__V_Natnat_64(state__[2],_tmp84_,_tmp37_);
  _tmp85_ = 6;
  BitRotR_eve__V_Natnat_64(state__[2],_tmp85_,_tmp39_);
  for (int _mask_idx = 0; _mask_idx <= (MASKING_ORDER - 1); _mask_idx++) {
    _tmp40_ = XOR(_tmp37_[_mask_idx],_tmp39_[_mask_idx]);
    stateR__[2][_mask_idx] = XOR(state__[2][_mask_idx],_tmp40_);
  }
  _tmp86_ = 10;
  BitRotR_eve__V_Natnat_64(state__[3],_tmp86_,_tmp42_);
  _tmp87_ = 17;
  BitRotR_odd__V_Natnat_64(state__[3],_tmp87_,_tmp44_);
  for (int _mask_idx = 0; _mask_idx <= (MASKING_ORDER - 1); _mask_idx++) {
    _tmp45_ = XOR(_tmp42_[_mask_idx],_tmp44_[_mask_idx]);
    stateR__[3][_mask_idx] = XOR(state__[3][_mask_idx],_tmp45_);
  }
  _tmp88_ = 7;
  BitRotR_odd__V_Natnat_64(state__[4],_tmp88_,_tmp47_);
  _tmp89_ = 40;
  BitRotR_eve__V_Natnat_64(state__[4],_tmp89_,_tmp49_);
  for (int _mask_idx = 0; _mask_idx <= (MASKING_ORDER - 1); _mask_idx++) {
    _tmp50_ = XOR(_tmp47_[_mask_idx],_tmp49_[_mask_idx]);
    stateR__[4][_mask_idx] = XOR(state__[4][_mask_idx],_tmp50_);
  }

}

void CoreRound__V64 (/*inputs*/ DATATYPE c__[5][MASKING_ORDER],DATATYPE cst__[MASKING_ORDER], /*outputs*/ DATATYPE cR__[5][MASKING_ORDER]) {

  // Variables declaration
  DATATYPE _tmp51_[5][MASKING_ORDER];
  DATATYPE _tmp52_[5][MASKING_ORDER];

  // Instructions (body)
  AddConstant__V64(c__,cst__,_tmp51_);
  Sbox__V64(_tmp51_,_tmp52_);
  LinearLayer__V64(_tmp52_,cR__);

}

void Accumulate__V64 (/*inputs*/ DATATYPE r__[2][MASKING_ORDER],DATATYPE c__[5][MASKING_ORDER], /*outputs*/ DATATYPE rR__[2][MASKING_ORDER]) {

  // Variables declaration
  DATATYPE _tmp53_;
  DATATYPE _tmp54_;
  DATATYPE _tmp55_;
  DATATYPE _tmp56_;
  DATATYPE _tmp57_;
  DATATYPE _tmp58_;
  DATATYPE _tmp59_;
  DATATYPE _tmp60_;

  // Instructions (body)
  for (int _mask_idx = 0; _mask_idx <= (MASKING_ORDER - 1); _mask_idx++) {
    _tmp53_ = XOR(r__[0][_mask_idx],c__[0][_mask_idx]);
    _tmp54_ = R_SHIFT(c__[2][_mask_idx],32,64);
    _tmp55_ = XOR(_tmp53_,_tmp54_);
    _tmp56_ = L_SHIFT(c__[3][_mask_idx],32,64);
    rR__[0][_mask_idx] = XOR(_tmp55_,_tmp56_);
    _tmp57_ = XOR(r__[1][_mask_idx],c__[1][_mask_idx]);
    _tmp58_ = R_SHIFT(c__[3][_mask_idx],32,64);
    _tmp59_ = XOR(_tmp57_,_tmp58_);
    _tmp60_ = L_SHIFT(c__[2][_mask_idx],32,64);
    rR__[1][_mask_idx] = XOR(_tmp59_,_tmp60_);
  }

}

/* main function */
void drysponge_g__ (/*inputs*/ DATATYPE c__[5][MASKING_ORDER], /*outputs*/ DATATYPE cR__[5][MASKING_ORDER],DATATYPE r__[2][MASKING_ORDER]) {

  // Variables declaration
  DATATYPE csts__[12][MASKING_ORDER];
  DATATYPE round_c__[5][MASKING_ORDER];
  DATATYPE round_r__[2][MASKING_ORDER];

  // Instructions (body)
  csts__[0][0] = LIFT_64(240);
  for (int _mask_idx = 1; _mask_idx <= (MASKING_ORDER - 1); _mask_idx++) {
    csts__[0][_mask_idx] = LIFT_64(0);
    csts__[1][_mask_idx] = LIFT_64(0);
    csts__[2][_mask_idx] = LIFT_64(0);
    csts__[3][_mask_idx] = LIFT_64(0);
    csts__[4][_mask_idx] = LIFT_64(0);
    csts__[5][_mask_idx] = LIFT_64(0);
    csts__[6][_mask_idx] = LIFT_64(0);
    csts__[7][_mask_idx] = LIFT_64(0);
    csts__[8][_mask_idx] = LIFT_64(0);
    csts__[9][_mask_idx] = LIFT_64(0);
    csts__[10][_mask_idx] = LIFT_64(0);
    csts__[11][_mask_idx] = LIFT_64(0);
    round_r__[0][_mask_idx] = LIFT_64(0);
    round_r__[1][_mask_idx] = LIFT_64(0);
  }
  csts__[1][0] = LIFT_64(225);
  csts__[2][0] = LIFT_64(210);
  csts__[3][0] = LIFT_64(195);
  csts__[4][0] = LIFT_64(180);
  csts__[5][0] = LIFT_64(165);
  csts__[6][0] = LIFT_64(150);
  csts__[7][0] = LIFT_64(135);
  csts__[8][0] = LIFT_64(120);
  csts__[9][0] = LIFT_64(105);
  csts__[10][0] = LIFT_64(90);
  csts__[11][0] = LIFT_64(75);
  for (int _mask_idx = 0; _mask_idx <= (MASKING_ORDER - 1); _mask_idx++) {
    round_c__[0][_mask_idx] = c__[0][_mask_idx];
    round_c__[1][_mask_idx] = c__[1][_mask_idx];
    round_c__[2][_mask_idx] = c__[2][_mask_idx];
    round_c__[3][_mask_idx] = c__[3][_mask_idx];
    round_c__[4][_mask_idx] = c__[4][_mask_idx];
  }
  round_r__[0][0] = LIFT_64(0);
  round_r__[1][0] = LIFT_64(0);
  for (int i__ = 0; i__ <= 10; i__++) {
    CoreRound__V64(round_c__,csts__[i__],round_c__);
    Accumulate__V64(round_r__,round_c__,round_r__);
  }
  for (int _mask_idx = 0; _mask_idx <= (MASKING_ORDER - 1); _mask_idx++) {
    cR__[0][_mask_idx] = round_c__[0][_mask_idx];
    cR__[1][_mask_idx] = round_c__[1][_mask_idx];
    cR__[2][_mask_idx] = round_c__[2][_mask_idx];
    cR__[3][_mask_idx] = round_c__[3][_mask_idx];
    cR__[4][_mask_idx] = round_c__[4][_mask_idx];
    r__[0][_mask_idx] = round_r__[0][_mask_idx];
    r__[1][_mask_idx] = round_r__[1][_mask_idx];
  }

}

/* Additional functions */
uint32_t bench_speed() {
  /* inputs */
  DATATYPE c__[5][MASKING_ORDER][MASKING_ORDER] = { 0 };
  /* outputs */
  DATATYPE cR__[5][MASKING_ORDER][MASKING_ORDER] = { 0 };
  DATATYPE r__[2][MASKING_ORDER][MASKING_ORDER] = { 0 };
  /* fun call */
  drysponge_g__(c__,cR__, r__);

  /* Returning the number of encrypted bytes */
  return 0;
}

/* **************************************************************** */
/*                            Usuba source                          */
/*                                                                  */
/*

 table Sbox(x :  v5 :: base)
  returns y :  v5 :: base
{
  4, 11, 31, 20, 26, 21, 9, 2, 27, 5, 8, 18, 29, 3, 6, 28, 30, 19, 7, 14, 0, 13, 17, 24, 16, 12, 1, 25, 22, 10, 15, 23
}


 node AddConstant(state :  u64x5 :: base,c :  u64 :: base)
  returns stateR :  u64x5 :: base
vars

let
  (stateR) = (state[0,1],(state[2] ^ c),state[3,4])
tel

 node Rotr32(x :  u64 :: base,n :  nat :: base)
  returns y :  u64 :: base
vars

let
  (y) = (((x >> n) ^ (x << (32 - n))) & 4294967295)
tel

_inline node BitRotR_odd(x :  u64 :: base,shift :  nat :: base)
  returns y :  u64 :: base
vars
  i0 :  u64 :: base,
  i1 :  u64 :: base,
  t :  u64 :: base
let
  (i0) = (x & 4294967295);
  (i1) = (x >> 32);
  (t) = Rotr32(i1,(shift / 2));
  (i1) := Rotr32(i0,(((shift / 2) + 1) % 32));
  (i0) := t;
  (y) = ((i1 << 32) ^ (i0 & 4294967295))
tel

_inline node BitRotR_eve(x :  u64 :: base,shift :  nat :: base)
  returns y :  u64 :: base
vars
  i0 :  u64 :: base,
  i1 :  u64 :: base
let
  (i0) = (x & 4294967295);
  (i1) = (x >> 32);
  (i0) := Rotr32(i0,(shift / 2));
  (i1) := Rotr32(i1,(shift / 2));
  (y) = ((i1 << 32) ^ (i0 & 4294967295))
tel

 node LinearLayer(state :  u64x5 :: base)
  returns stateR :  u64x5 :: base
vars

let
  (stateR[0]) = (state[0] ^ (BitRotR_odd(state[0],19) ^ BitRotR_eve(state[0],28)));
  (stateR[1]) = (state[1] ^ (BitRotR_odd(state[1],61) ^ BitRotR_eve(state[1],38)));
  (stateR[2]) = (state[2] ^ (BitRotR_odd(state[2],1) ^ BitRotR_eve(state[2],6)));
  (stateR[3]) = (state[3] ^ (BitRotR_eve(state[3],10) ^ BitRotR_odd(state[3],17)));
  (stateR[4]) = (state[4] ^ (BitRotR_odd(state[4],7) ^ BitRotR_eve(state[4],40)))
tel

 node CoreRound(c :  u64x5 :: base,cst :  u64 :: base)
  returns cR :  u64x5 :: base
vars

let
  (cR) = LinearLayer(Sbox(AddConstant(c,cst)))
tel

 node Accumulate(r :  u64x2 :: base,c :  u64x5 :: base)
  returns rR :  u64x2 :: base
vars

let
  (rR[0]) = (((r[0] ^ c[0]) ^ (c[2] >> 32)) ^ (c[3] << 32));
  (rR[1]) = (((r[1] ^ c[1]) ^ (c[3] >> 32)) ^ (c[2] << 32))
tel

 node drysponge_g(c :  u64x5 :: base)
  returns cR :  u64x5 :: base,r :  u64x2 :: base
vars
  csts :  u64[12] :: base,
  round_c :  u64x5[12] :: base,
  round_r :  u64x2[12] :: base
let
  (csts) = (240,225,210,195,180,165,150,135,120,105,90,75);
  (round_c[0]) = c;
  (round_r[0]) = (0,0);
  forall i in [0,10] {
    (round_c[(i + 1)]) = CoreRound(round_c[i],csts[i]);
    (round_r[(i + 1)]) = Accumulate(round_r[i],round_c[(i + 1)])
  };
  (cR) = round_c[11];
  (r) = round_r[11]
tel

*/
 